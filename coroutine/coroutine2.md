# Coroutine (2) 协程的实现方式

原文URL：https://blog.csdn.net/hehe123456ZXC/article/details/52514490


## 1、协程是啥

从**线程**的角度认识**协程**，**协程**其实可以认为是比**线程**更小的**执行单元**。

为啥说他是一个执行单元，因为它自带**CPU上下文**。这样只要在合适的时机，我们可以把**一个协程** 切换到 **另一个协程**。只要这个过程中保存或恢复 **CPU上下文**那么程序还是可以运行的。

## 2、协程与线程的实现差异

那么这个过程看起来比线程差不多哇。其实不然。

**线程**切换，从**系统层面**，远不止 **保存和恢复 CPU上下文** 这么简单。操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作。所以线程的切换非常耗性能。

但是**协程**的切换只是单纯的操作**CPU的上下文**，所以一秒钟切换个上百万次系统都抗的住。

## 3、协程的实现

但是协程有一个问题，就是系统并不感知，所以操作系统不会帮你做切换。那么谁来帮你做切换？**让需要执行的协程更多的获得CPU时间才是问题的关键**。

### 3.1、协程是如何实现的？

目前的协程框架一般都是设计成 1:N 模式。所谓 1:N 就是一个线程作为一个容器里面放置多个协程。那么谁来适时的切换这些协程？

答案是由协程自己主动让出CPU。也就是，每个协程池里面有一个调度器，这个调度器是被动调度的。所谓“被动调度”，意思就是它不会主动调度。当一个协程发现自己执行不下去了(比如，异步等待网络的数据回来时，但是当前还没有数据到)，这个时候就可以由这个协程通知调度器，这个时候执行到调度器的代码，调度器根据事先设计好的调度算法找到当前最需要CPU的协程。切换这个协程的CPU上下文把CPU的运行权交个这个协程，直到这个协程出现执行不下去需要等等的情况，或者它调用主动让出CPU的API之类，触发下一次调度。对的，没错，这就是类似于 领导人模式。

简言之，协程的全部精神就在于控制流的主动让出和恢复。
参考URL：https://blog.youxu.info/2014/12/04/coroutine/

### 3.2、那么这个实现有没有问题？

其实是有问题的，假设这个线程中有一个协程是CPU密集型的,它没有IO操作，也就是自己不会主动触发调度器调度的过程，那么就会出现其他协程得不到执行的情况，所以这种情况下需要程序员自己避免。这是一个问题，假设业务开发的人员并不懂这个原理的话就可能会出现问题。

## 4、最后讲讲协程的好处

在IO密集型的程序中，由于IO操作远远小于CPU的操作，所以往往需要CPU去等IO操作。同步IO下，系统需要切换线程，让操作系统可以在IO过程中执行其他的东西。这样虽然代码是符合人类的思维习惯但是由于大量的线程切换带来了大量的性能的浪费，尤其是IO密集型的程序。

所以人们发明了异步IO。就是当数据到达的时候触发我的回调。来减少线程切换带来性能损失。但是这样的坏处也是很大的，主要的坏处就是操作被   “分片”  了，代码写的不是 “一气呵成” 这种。 而是每次来段数据就要判断：数据够不够处理哇，够处理就处理吧，不够处理就在等等吧。这样代码的可读性很低，其实也不符合人类的习惯。  

但是协程可以很好解决这个问题。比如 把一个IO操作 写成一个协程。当触发IO操作的时候就自动让出CPU给其他协程。要知道协程的切换很轻的。协程通过这种对异步IO的封装 既保留了性能也保证了代码的 容易编写和可读性。

在高IO密集型的程序下，使用协程很好；但是，高CPU密集型的程序下，使用协程没啥好处。

